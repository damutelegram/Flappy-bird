<!doctype html>

<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flappy Bird — HTML5</title>
  <style>
    :root{--bg:#70c5ce;--ground:#ded895;--bird:#ffdd57;--pipe:#2ea44f}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(#a0e9ff,#70c5ce);padding:12px}
    .game-wrap{width:100%;max-width:480px;background:transparent}
    canvas{display:block;width:100%;height:auto;border-radius:8px;box-shadow:0 8px 30px rgba(15,30,40,0.18)}
    .hint{position:relative;margin-top:8px;color:#033; text-align:center}
    .credits{font-size:12px;color:rgba(0,0,0,0.45);text-align:center;margin-top:6px}
  </style>
</head>
<body>
  <div class="game-wrap">
    <canvas id="game"></canvas>
    <div class="hint">Нажмите пробел или тапните по экрану, чтобы лететь. Нажмите R чтобы перезапустить.</div>
    <div class="credits">Простой клон Flappy Bird — можно сохранить как файл .html и открыть в браузере</div>
  </div><script>
(() => {
  // Canvas setup with DPR scaling
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resize() {
    const cssW = Math.min(480, window.innerWidth - 24);
    const cssH = Math.max(600, Math.round(cssW * (800/480)));
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Game variables
  const G = {gravity: 0.55, jump: -9, pipeSpeed: 2.2};
  let state = 'start'; // 'start' | 'playing' | 'gameover'
  let score = 0;

  const bird = {
    x: 80,
    y: 200,
    r: 14,
    vy: 0,
    rotation: 0
  };

  let pipes = [];
  let frame = 0;
  const pipeInterval = 95; // frames between pipes
  const pipeWidth = 64;

  function reset() {
    bird.y = canvas.height/4;
    bird.vy = 0;
    bird.rotation = 0;
    pipes = [];
    score = 0;
    frame = 0;
    state = 'start';
  }

  function spawnPipe() {
    const ch = parseFloat(canvas.style.height);
    const gap = Math.max(110, Math.round(ch * 0.18));
    const minTop = 40;
    const maxTop = ch - gap - 80;
    const top = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;
    pipes.push({x: canvas.width / (window.devicePixelRatio||1) + 10, top, gap, width: pipeWidth, passed: false});
  }

  function circleRectCollide(cx, cy, r, rx, ry, rw, rh) {
    // Find closest point
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  function update() {
    frame++;
    if (state === 'playing') {
      // bird physics
      bird.vy += G.gravity;
      bird.y += bird.vy;
      bird.rotation = Math.max(Math.min(bird.vy * 3, 45), -45);

      // pipes
      for (let p of pipes) {
        p.x -= G.pipeSpeed;
        // scoring
        if (!p.passed && p.x + p.width < bird.x - bird.r) {
          p.passed = true;
          score++;
        }
      }
      // remove offscreen
      pipes = pipes.filter(p => p.x + p.width > -20);

      // spawn
      if (frame % pipeInterval === 0) spawnPipe();

      // collisions
      // ground and ceiling
      const ch = canvas.height / (window.devicePixelRatio||1);
      if (bird.y + bird.r >= ch - 12 || bird.y - bird.r <= 0) {
        state = 'gameover';
      }
      for (let p of pipes) {
        // top pipe rect
        const rx = p.x;
        const rw = p.width;
        const topRect = {x: rx, y: 0, w: rw, h: p.top};
        const botRect = {x: rx, y: p.top + p.gap, w: rw, h: ch - (p.top + p.gap)};
        if (circleRectCollide(bird.x, bird.y, bird.r, topRect.x, topRect.y, topRect.w, topRect.h)
          || circleRectCollide(bird.x, bird.y, bird.r, botRect.x, botRect.y, botRect.w, botRect.h)) {
          state = 'gameover';
        }
      }

    } else if (state === 'start') {
      // gentle bob
      bird.vy = Math.sin(frame/10) * 0.7;
      bird.y += bird.vy;
      bird.rotation = Math.sin(frame/10) * 6;
      if (frame % pipeInterval === 0) spawnPipe();
      for (let p of pipes) p.x -= G.pipeSpeed/2;
      pipes = pipes.filter(p => p.x + p.width > -20);
    }
  }

  function draw() {
    const w = canvas.width / (window.devicePixelRatio||1);
    const h = canvas.height / (window.devicePixelRatio||1);
    // background
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#70c5ce';
    ctx.fillRect(0,0,w,h);

    // pipes
    for (let p of pipes) {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe') || '#2ea44f';
      // top
      ctx.fillRect(p.x, 0, p.width, p.top);
      // bottom
      ctx.fillRect(p.x, p.top + p.gap, p.width, h - (p.top + p.gap));
      // caps (rounded)
      ctx.fillStyle = '#1f8a3a';
      ctx.fillRect(p.x, p.top - 8, p.width, 8);
      ctx.fillRect(p.x, p.top + p.gap, p.width, 8);
    }

    // ground
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground') || '#ded895';
    ctx.fillRect(0, h-12, w, 12);

    // bird (circle with beak and eye)
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(bird.rotation * Math.PI / 180);
    // body
    ctx.beginPath();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bird') || '#ffdd57';
    ctx.arc(0,0,bird.r,0,Math.PI*2);
    ctx.fill();
    // wing (simple)
    ctx.beginPath();
    ctx.ellipse(-2, 2, 8, 5, Math.PI/6, 0, Math.PI*2);
    ctx.fillStyle = '#f0c94a';
    ctx.fill();
    // eye
    ctx.beginPath();
    ctx.fillStyle = '#222';
    ctx.arc(6, -4, 3, 0, Math.PI*2);
    ctx.fill();
    // beak
    ctx.beginPath();
    ctx.fillStyle = '#ff8b2b';
    ctx.moveTo(bird.r, -3);
    ctx.lineTo(bird.r + 12, 0);
    ctx.lineTo(bird.r, 6);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // score
    ctx.fillStyle = '#073642';
    ctx.font = 'bold 34px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(score, w/2, 60);

    // messages
    ctx.fillStyle = 'rgba(5,10,15,0.85)';
    ctx.font = '16px system-ui, Arial';
    ctx.textAlign = 'center';
    if (state === 'start') {
      ctx.fillText('Нажмите пробел или тапните — чтобы начать', w/2, h/2 - 20);
    }
    if (state === 'gameover') {
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.font = '26px system-ui, Arial';
      ctx.fillText('Игра окончена', w/2, h/2 - 10);
      ctx.font = '16px system-ui, Arial';
      ctx.fillText('Нажмите пробел или тапните чтобы перезапустить', w/2, h/2 + 20);
      ctx.fillText('Ваш счёт: ' + score, w/2, h/2 + 46);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  function flap() {
    bird.vy = G.jump;
    if (state === 'start') {
      state = 'playing';
      // clear pipes and spawn fresh
      pipes = []; frame = 0; score = 0;
    }
    if (state === 'gameover') {
      reset();
      return;
    }
  }

  // input
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); flap(); }
    if (e.key === 'r' || e.key === 'R') reset();
  });
  canvas.addEventListener('mousedown', (e) => {
    e.preventDefault(); if (state === 'gameover') reset(); else flap();
  });
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); if (state === 'gameover') reset(); else flap();
  }, {passive:false});

  // start
  reset();
  loop();
})();
</script></body>
</html>
